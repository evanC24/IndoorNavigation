import Foundation
import CoreGraphics

/// A class representing a 2D map used for navigation and pathfinding.
/// The map is defined by its width, height, obstacles, and a grid of points that determines walkable and non-walkable areas.
/// - Features:
///   - Dynamic generation of a grid of points.
///   - Integration of obstacles to create realistic navigation challenges.
///   - Pathfinding capabilities using A* and path smoothing for optimized navigation.
/// - Availability: iOS 13.0+
@available(iOS 13.0, *)
public class Map {
    
    // MARK: - Properties
    
    /// The width of the map, representing its extent along the x-axis.
    public var width: Float
    
    /// The height of the map, representing its extent along the y-axis.
    public var height: Float
    
    /// A collection of obstacles on the map, which define non-walkable regions.
    public var obstacles: [any Obstacle]
    
    /// The distance between adjacent points in the grid, determining the map's resolution.
    public var step: Float = 0.1
    
    /// The threshold distance from obstacles that is considered unsafe.
    /// Points within this distance of an obstacle may incur additional costs.
    public let thresholdDistance: Float = 0.35
    
    /// A 2D array of `Point` objects representing the grid of the map.
    /// Each point is classified as walkable or non-walkable based on its proximity to obstacles.
    public var points: [[Point]] = []
    
    // MARK: - Initializers
    
    /// Initializes a `Map` instance with the specified dimensions and obstacles.
    /// - Parameters:
    ///   - width: The width of the map along the x-axis.
    ///   - height: The height of the map along the y-axis.
    ///   - obstacles: An array of `Obstacle` objects defining non-walkable regions.
    public init(width: Float, height: Float, obstacles: [any Obstacle]) {
        self.width = width
        self.height = height
        self.obstacles = obstacles
        self.generatePoints()
    }
    
    // MARK: - Grid Generation
    
    /// Generates a grid of points based on the map's dimensions and step size.
    /// Each point is classified as walkable if it is not located within any obstacle.
    ///
    /// - Stores the generated points in the `points` property as a 2D array.
    private func generatePoints() {
        var y: Float = 0
        while y <= height {
            var row = [Point]()
            var x: Float = 0
            while x <= width {
                let roundedX = roundToDecimal(x, places: 2)
                let roundedY = roundToDecimal(y, places: 2)
                
                // Check if the point is outside all obstacles.
                let isWalkable = !isInObstacleArea(Point(x: x, y: y))
                
                row.append(Point(x: roundedX, y: roundedY, heading: nil, isWalkable: isWalkable))
                x += step
            }
            points.append(row)
            y += step
        }
    }
    
    // MARK: - Pathfinding
    
    /// Finds a path between two points using the A* search algorithm.
    /// - Parameters:
    ///   - start: The starting point of the path.
    ///   - goal: The goal point of the path.
    /// - Returns: An array of `Point` objects representing the path, or `nil` if no path is found.
    public func findPath(start: Point, goal: Point) -> [Point]? {
        let graph = Graph(neighbors: { return self.getNeighbors(point: $0) })
        return graph.aStarSearch(start: start, end: goal, cost: proximityCost, heuristic: euclideanDistance(from:to:))
    }
    
    /// Smooths a path by removing unnecessary waypoints while ensuring visibility between consecutive points.
    /// - Parameter inputPath: The original path generated by A*.
    /// - Returns: A smoothed path with fewer waypoints for optimized navigation.
    public func smoothPath(inputPath: [Point]) -> [Point] {
        guard inputPath.count > 2 else { return inputPath }
        var outputPath: [Point] = [inputPath[0]]
        var inputIndex = 2
        
        while inputIndex < inputPath.count {
            if !isLineOfSight(start: outputPath.last!, end: inputPath[inputIndex], obstacles: self.obstacles) {
                outputPath.append(inputPath[inputIndex - 1])
            }
            inputIndex += 1
        }
        outputPath.append(inputPath.last!)
        return outputPath
    }
    
    // MARK: - Utility Methods
    
    /// Determines the walkable neighbors of a given point.
    /// - Parameter point: The point for which to find neighbors.
    /// - Returns: An array of neighboring `Point` objects that are walkable.
    public func getNeighbors(point: Point) -> [Point] {
        let xIndex = Int(round(point.x / step))
        let yIndex = Int(round(point.y / step))
        
        var neighbors = [Point]()
        let width = points[0].count
        let height = points.count
        
        let directions = [
            (-1, -1), (1, 1), (-1, 1), (1, -1),  // Diagonal
            (0, -1), (0, 1), (-1, 0), (1, 0),   // Cardinal
        ]
        
        for neighbor in directions {
            let newYIndex = yIndex + neighbor.0
            let newXIndex = xIndex + neighbor.1
            
            if newYIndex >= 0, newYIndex < height, newXIndex >= 0, newXIndex < width {
                let potentialNeighbor = points[newYIndex][newXIndex]
                if !isInObstacleArea(potentialNeighbor) {
                    neighbors.append(potentialNeighbor)
                }
            }
        }
        return neighbors
    }
    
    /// Determines if a point lies within an obstacle.
    /// - Parameter potentialNeighbor: The point to evaluate.
    /// - Returns: `true` if the point lies inside an obstacle, `false` otherwise.
    fileprivate func isInObstacleArea(_ potentialNeighbor: Point) -> Bool {
        return obstacles.contains { $0.contains(point: potentialNeighbor, safeArea: false) }
    }
    
    /// Calculates the cost of a point based on its proximity to obstacles.
    /// - Parameter point: The point being evaluated.
    /// - Returns: A higher cost for points near obstacles, or 0 for safe points.
    public func proximityCost(_ point: Point) -> Float {
        return Float(obstaclesTooNear(from: point))
    }
    
    /// Counts the number of obstacles too close to a point based on the threshold distance.
    /// - Parameter point: The point being evaluated.
    /// - Returns: The count of obstacles within the unsafe distance.
    public func obstaclesTooNear(from point: Point) -> Int {
        return obstacles.count(where: { $0.distanceTo(point: point) < thresholdDistance })
    }
}
